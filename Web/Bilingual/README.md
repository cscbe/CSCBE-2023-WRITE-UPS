The `TranslationService` can be used to perform an SSRF targetting the Redis
server by trying to translate to the language 'redis'. The tricky part is to
build a valid payload that Redis will correctly parse.

Assume our userId is aaaaaabc-dddd-dddd-dddd-d.

The Redis command we want to execute is `SET admin.aaaaaabc-dddd-dddd-dddd-d y`.
According to the [Redis protocol spec](https://redis.io/docs/reference/protocol-spec/)
this command should be serialized as:

```
*3
$3
SET
$31
admin.aaaaaabc-dddd-dddd-dddd-d
$1
y
```

Please do note that newlines are supposed to be `\r\n`.

Now how do we build a valid TranslationRpcRequest protobuffer that executes this
command? Let's analyse the proto with the [protobuffer write format spec](https://developers.google.com/protocol-buffers/docs/encoding).

Let's assume all fields are set, then this is what the serialized protobuffer
will look like:

1. Because of the text, the buffer will start with `*` followed by a byte 
    representing the length of the text. The next bytes will be the actual text.
2. Then the metadata gets serialized. So the next character will be `2` and then
    the length (in bytes) of the metadata serialization.
3. Then we get a `-` and 4 bytes representing a little endian integer for each 
    change_timestamp.
4. The bounty will cause the next character to be a `1` followed by the 64 bit
    LE encoding of the bounty.
5. Finally the flags will emit a `:` followed by the number of flags and 
    then the serialized flags. 
    (It's actually the number of bytes, but each flag fits in 1 byte)

The first thing that catches our attention is the dashes generated by 3. Can we
use these to output the dashes in our user id? Yes, we can by simply adding 4
change timestamps: 
`[toInt('dddd'),toInt('dddd'),toInt('dddd'),toInt('d\r\n$')]`.
These last 3 characters in the last timestamp are the 3 next characters in our
target payload. Then `bounty` will add the next `1` and we can control the final
required characters by setting bounty to `toInt(\r\ny\r\n)`.

Now we only needs to build the first part of the payload.
From point 2 we can conclude that the 7th character of the user id has to be a 
`2`. We can simply keep making accounts until we get an id that satisfies this
constraint (1/16 chance).
The ascii value of 8th character of the id must be the length of the serialized
metadata. To achieve this, we can keep adding flags until the length is correct.
These trailing bytes will cause Redis to return an error, but that's not a 
problem as it will only do so after executing the SET command.

Only a couple more character to go. Ideally the text would be 51 characters 
long, so the second character of the payload is a `3`. Unfortunately there are
not enough characters left. What do we do now? We add more characters!

We can use pipelining to send multiple commands to pad our payload. Pipelining
is just sending multiple commands in succession. For example:

```
*2
$3
GET
$X
YYYYY
*3
$3
SET
$31
admin.aaaaaabc-dddd-dddd-dddd-d
$1
y
```

Or in a human readable format: 
```
GET YYYYY
SET admin.aaaaaabc-dddd-dddd-dddd-d y
```

It turns out that when X = 3 (and YYYYY is for example `pad`), the rest of our
payload will align perfectly.

We now have a payload that allows us to set the admin bit for our user!
All that's left to do now is to visit `/flag`.

Flag: CSC{G00d_to_s33_you_4r3_b1l1ngu4l!_a71523321c}
